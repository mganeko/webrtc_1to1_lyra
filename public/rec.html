<!doctype html>
<html>

<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Lyra rec/play</title>
</head>

<!-- TODO
  [ ] write/read local file with File System Access API
  [ ] rec/play PCM
  [ ] rec/play Lyra
  [ ] use container file for media
-->

<script>
  async function getFileHandleToWrite(name) {
    const handle = await window.showSaveFilePicker({ suggestedName: name });
    return handle;
  }

  async function getFileHandleToRead(name) {
    const handles = await window.showOpenFilePicker({
      types: [
        {
          description: 'data',
          accept: {
            'data/*': ['.dat', '.wav', '.pcm']
          }
        },
      ],
      multiple: false
    });

    if (handles.length >= 1) {
      return handles[0];
    }
    else {
      return null;
    }
  }

  let writable = null;
  async function writeTest() {
    const fileHandle = await getFileHandleToWrite('write_test.dat');
    //const file = await fileHandle.getFile();
    //let fileContents = await file.text();

    writable = await fileHandle.createWritable();
    //await writable.write("aBCdefg\n");
    //writable.close();
  }

  async function slecetWritable() {
    const fileHandle = await getFileHandleToWrite('pcm_test.dat');
    writable = await fileHandle.createWritable();
  }
  
  //let readFile = null;
  let dataArray = null;
  async function slecetReadable() {
    const fileHandle = await getFileHandleToRead('pcm_test.dat');
    const readFile = await fileHandle.getFile();
    dataArray = await readFile.arrayBuffer();
    console.log("loaded data:", dataArray);
  }
  
  const PCM_SAMPLE_RATE = 48000;
  async function playbackPCM() {
    if (!audioCtx) {
      audioCtx = new AudioContext();
    }

    if (!dataArray) {
      console.warn('--data not loaded');
      return;
    }

    const int16_buffer = new Int16Array(dataArray);
    const audioBuffer = audioCtx.createBuffer(1, int16_buffer.length, PCM_SAMPLE_RATE);

    const MAX_INT = 2**15 - 1;
    const nowBuffering = audioBuffer.getChannelData(0);
    for (let i = 0; i < int16_buffer.length; i++) {
      const data = int16_buffer[i];
      nowBuffering[i] = data / MAX_INT;
    }

    // AudioBufferSourceNode を得る
    // これは AudioBuffer を再生するときに使う AudioNode である
    const source = audioCtx.createBufferSource();

    // AudioBufferSourceNode にバッファーを設定する
    source.buffer = audioBuffer;

    // AudioBufferSourceNode を出力先に接続すると音声が聞こえるようになる
    source.connect(audioCtx.destination);

    // 音源の再生を始める
    source.start();
  }

  // --- media ----
  let audioCtx = null;

  let localStream = null;
  async function startMedia() {
    if (!audioCtx) {
      audioCtx = new AudioContext();
    }

    const options = {
      video: false,
      audio: true
      //audio: { sampleRate: 16000 }
    };
    const stream = await navigator.mediaDevices.getUserMedia(options);
    if (stream) {
      localStream = stream;
      startRec();
    }
  }

  function stopMedia() {
    if (localStream) {
      localStream.getTracks().forEach(track => track.stop());
      localStream = null;
    }

    if (writable) {
      writable.close();
      writable = null;
    }
  }

  // 
  //  MediaStreamTrackProcessor
  //    https://github.com/mayitayew/lyra-demo/blob/main/index.js
  //  
  //
  let processor = null;
  let generator = null;
  let transformer = null;
  let encodeTransformer = null;
  let decodeTransformer = null;
  let processedStream = null;

  async function startRec() {
    if (!localStream) return;

    // WebAudio
    //const source = new MediaStreamAudioSourceNode(audioCtx, { mediaStream: localStream });
    //source.connect(audioCtx.destination);

    const audioTrack = localStream.getAudioTracks()[0];
    processor = new MediaStreamTrackProcessor( { track: audioTrack});
    generator = new MediaStreamTrackGenerator( { kind: 'audio'} );
    const source = processor.readable;
    const sink = generator.writable;
    
    //transformer = new TransformStream({transform: encodeAndDecode()});
    //source.pipeThrough(transformer).pipeTo(sink);

    encodeTransformer = new TransformStream({transform: encode()});
    decodeTransformer = new TransformStream({transform: decode()});
    source.pipeThrough(encodeTransformer).pipeThrough(decodeTransformer).pipeTo(sink);

    processedStream = new MediaStream();
    processedStream.addTrack(generator);
    
    const audio = document.getElementById('playback_audio');
    audio.srcObject = processedStream;
    await audio.play();
  }

  function encodeAndDecode() {
    return (audiodata, controller) => {

      // --- Do nothing --
      //controller.enqueue(audiodata);
      // --- Do nothing --

      // --- copy ---
      const format = 'f32-planar';
      const current_buffer = new Float32Array(audiodata.numberOfFrames);
      const int16_buffer = new Int16Array(audiodata.numberOfFrames);
      const float32_buffer = new Float32Array(audiodata.numberOfFrames);
      audiodata.copyTo(current_buffer, {planeIndex: 0, format});

      // --- conver to int16 ---
      const MAX_INT = 2**15 - 1;
      for (let i = 0; i < current_buffer.length; i++) {
        const data = current_buffer[i];
        if (data > 1) {
          int16_buffer[i] = MAX_INT;
          console.warn("--over 1");
        }
        else if (data < -1) {
          int16_buffer[i] = - MAX_INT;
          console.warn("--under -1");
        }
        else {
          int16_buffer[i] = Math.floor(data * MAX_INT);
        }
      }
      if (writable) {
        writable.write(int16_buffer);
      }

      // --- conver to float32 ---
      for (let i = 0; i < current_buffer.length; i++) {
        const data = int16_buffer[i];
        float32_buffer[i] = data / MAX_INT;
      }

      const newAudioData = new AudioData({
        format: format,
        sampleRate: audiodata.sampleRate,
        numberOfFrames: audiodata.numberOfFrames,
        numberOfChannels: 1,
        timestamp: audiodata.timestamp,
        
        // A typed array of audio data.
        //data: current_buffer,
        data: float32_buffer,
      });
      audiodata.close();

      controller.enqueue(newAudioData);
    }
  }

  function encode() {
    return (audiodata, controller) => {
      // --- copy ---
      const format = 'f32-planar';
      const newFormat = 's16-planar';
      const current_buffer = new Float32Array(audiodata.numberOfFrames);
      const int16_buffer = new Int16Array(audiodata.numberOfFrames);
      audiodata.copyTo(current_buffer, {planeIndex: 0, format});

      // --- conver to int16 ---
      const MAX_INT = 2**15 - 1;
      for (let i = 0; i < current_buffer.length; i++) {
        const data = current_buffer[i];
        if (data > 1) {
          int16_buffer[i] = MAX_INT;
          console.warn("--over 1");
        }
        else if (data < -1) {
          int16_buffer[i] = - MAX_INT;
          console.warn("--under -1");
        }
        else {
          int16_buffer[i] = Math.floor(data * MAX_INT);
        }
      }
      writePCM(int16_buffer);

      const newAudioData = new AudioData({
        format: newFormat,
        sampleRate: audiodata.sampleRate,
        numberOfFrames: audiodata.numberOfFrames,
        numberOfChannels: 1,
        timestamp: audiodata.timestamp,
        
        // A typed array of audio data.
        data: int16_buffer,
      });
      audiodata.close();

      controller.enqueue(newAudioData);
    }
  }

  function decode() {
    return (audiodata, controller) => {

      // --- copy ---
      const format = 's16-planar';
      const newFormat = 'f32-planar';
      const int16_buffer = new Int16Array(audiodata.numberOfFrames);
      const float32_buffer = new Float32Array(audiodata.numberOfFrames);
      audiodata.copyTo(int16_buffer, {planeIndex: 0, format});

      const MAX_INT = 2**15 - 1;

      // --- conver to float32 ---
      for (let i = 0; i < int16_buffer.length; i++) {
        const data = int16_buffer[i];
        float32_buffer[i] = data / MAX_INT;
      }

      const newAudioData = new AudioData({
        format: format,
        sampleRate: audiodata.sampleRate,
        numberOfFrames: audiodata.numberOfFrames,
        numberOfChannels: 1,
        timestamp: audiodata.timestamp,
        
        // A typed array of audio data.
        //data: current_buffer,
        data: float32_buffer,
      });
      audiodata.close();

      controller.enqueue(newAudioData);
    }
  }

  function writePCM(int32buf) {
    if (writable) {
      writable.write(int32buf);
    }
  }

</script>

<body>
  <button onclick="slecetWritable()">Write</button>
  <button type="button" onclick="startMedia();">Start Media</button>
  <button type="button" onclick="stopMedia();">Stop Media</button>
  &nbsp;
  <button onclick="slecetReadable()">Read</button>
  <button onclick="playbackPCM()">Play</button>
  <br />
  <audio id="playback_audio" controls="1" width="300px"></audio>
</body>

</html>